%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%FEM MATRIX FORMAT TO CELLSTRING TRANSLATOR%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function new_output_struct = fem_num2cell(input,file_type)

%converts the bulk data only or a data bulk in matrix format

%this script converts the numerical inputs into cell strings so that they
%can be printed into a text file for use with Altair OPtistruct (.fem file
%template) using the print out matlab code developed by Eric Trudel 2018
%FALL.

%interger values will be converted into integer strings regardless of the
%card it is attached to

%Input
%input : a data bulk structure of matrices generated by the function 'read_fem' or 'read_bdf'
%file_type : 'fem' or 'bdf'

%Output
%new_output_struct : cellstring format of the bulk data input 'input'

%Made for importing data into printable hypermesh or NASTRAN format (bulk data)
%file_type
% 'fem'
% 'bdf'
format long
new_output_struct = input;
switch upper(file_type)
    case {'FEM','.FEM'}
        cell_block_characters=8;
        full_line_text=80; 
    case {'BDF','.BDF'}
        cell_block_characters=8;
        full_line_text=80; %72?
    otherwise
        error('No model type selected, choose ''fem'' or ''bdf''')
end

number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters;
%number_of_cell_cols_elements = number_of_cell_cols -1;

struct_names = fieldnames(new_output_struct);

element_strings = {'CHEXA','CPYRA','CTETRA','CPENTA'};
elem_string2 = {'QUAD4','QUAD8','TRIA3','TRIA6','HEX8','HEX20','PENTA6','PENTA15','PYRAMID5','PYRAMID13','TETRA4','TETRA10'};
elem_string3 ={'REB2', 'RBE3'};
for i = 1:length(struct_names)

    block = new_output_struct.(struct_names{i});
    type = class(block);
    if ~contains(struct_names{i},{'PARAM', 'CONTROL_CARDS'}) %avoid updating feilds with strings
        switch type
            case 'cell'
                %repack into individual cells
                [~,cols] = size(block);
                switch upper(file_type)

                    %%%%%%%%%%%%%%%%%%%%%%%%
                    %FOR HYPERMESH TEMPLATE%
                    %%%%%%%%%%%%%%%%%%%%%%%%

                    case {'FEM','.FEM'}

                        %need to diffirentiate if it is a SET or RBE2
                        %need to add ELEM or Nodes...will need to be manually added by
                        %the user...

                        if contains(struct_names{i}(1:3),'SET')
                            %is a set
                            %made up of cells
                            %first cell is the set ID
                            %have the second cell empty
                            %have the third cell equal to "LIST"
                            %node ids start at the second row  
                            %sets used for contact meshing and modeling (for
                            %lattice stuff)
                             number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters -1 ;
                             for d = 1:cols
                                    sub_block=block{d}; 
                                    %add required cells
                                    cell_row = mat2cell(sub_block,1,ones(numel(sub_block),1)); %#ok<MMTC>
                                    %make first row and append
                                    cell_row = [cell_row(1) cell(1) {'LIST'} cell(1,number_of_cell_cols-3) cell_row(2:end)];
                                    %check if cell_row is a multiple of number
                                    %of cols
                                    cells_num = numel(cell_row);
                                    num2add =number_of_cell_cols*ceil(cells_num/number_of_cell_cols) - cells_num;
                                    if num2add>0
                                        cell_add  = cell(1,num2add);
                                        cell_row = [cell_row cell_add] ;                                     %#ok<AGROW>
                                    end
                                    %reshape the cells
                                    cell_row=(reshape(cell_row,number_of_cell_cols,ceil(numel(cell_row)/number_of_cell_cols))');
                                    bool = cellfun(@isempty,cell_row);
                                    cell_row(~bool) = cellfun(@num2str, cell_row(~bool),'UniformOutput', false);
                                    cell_row(bool)={repmat(' ',1,cell_block_characters)}; %replace empty cells with whitespace
                                    new_output_struct.(struct_names{i}){d}=cell_row;
                            end

                        else
                            %is not a set (RBE2 for example)
                            %made up of an array
                            %cols is set to 8 for rigids, or else hypermesh will not
                            %register anything past the 8th cell/block
                            new_output_struct = read_general_chain(new_output_struct,struct_names,number_of_cell_cols,cell_block_characters,block,cols,i);
                       end

                    case {'BDF','.BDF'}

                        %%%%%%%%%%%%%%%%%%%%%%
                        %FOR NASTRAN TEMPLATE%
                        %%%%%%%%%%%%%%%%%%%%%%

                        %RB3 have a space after the ID number
                        
                        if contains(struct_names{i}(1:min(length(struct_names{i}),4)),'RBE3') %|| contains(struct_names{i}(1:min(length(struct_names{i}),3)),'SET')
                            %have the second cell equal to "empty" 
                            number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters -1 ;
                            for d = 1:cols
                                    sub_block=block{d}; 
                                    %add required cells
                                    cell_row = mat2cell(sub_block,1,ones(numel(sub_block),1)); %#ok<MMTC>
                                    %add blank here
                                    cell_row = [cell_row(1) cell(1) cell_row(2:end)];
                                    %check if cell_row is a multiple of number
                                    %of cols
                                    cells_num = numel(cell_row);
                                    num2add =number_of_cell_cols*ceil(cells_num/number_of_cell_cols) - cells_num;
                                    if num2add>0
                                        cell_add  = cell(1,num2add);
                                        cell_row = [cell_row cell_add] ;                                     %#ok<AGROW>
                                    end
                                    %reshape the cells
                                    cell_row=(reshape(cell_row,number_of_cell_cols,ceil(numel(cell_row)/number_of_cell_cols))');
                                    bool = cellfun(@isempty,cell_row);
                                    cell_row(~bool) = cellfun(@num2str, cell_row(~bool),'UniformOutput', false);
                                    cell_row(bool)={repmat(' ',1,cell_block_characters)}; %replace empty cells with whitespace
                                    new_output_struct.(struct_names{i}){d}=cell_row;
                            end

                        else
                            %For the other types (RBE2)
                            number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters -1 ;
                            new_output_struct = read_general_chain(new_output_struct,struct_names,number_of_cell_cols,cell_block_characters,block,cols,i);

                        end

                end

            case 'double'

                %is a matrix to be converted into the cell string format
                %quick_convert = sprintfc('%d',block);
                %need to update all non integer values for forces, grids and materials...   

                switch upper(file_type)
                    case {'FEM','.FEM'}                
                        if contains(struct_names{i},[element_strings elem_string2 elem_string3])
                            %disp("3D Element")
                            %number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters - 1; %because of problems with CHEXA elements
                            number_of_cell_cols = 8;
                        else
                            
                            number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters;
                        end
                    case {'BDF','.BDF'}
                        if contains(struct_names{i},[element_strings elem_string2 elem_string3])
                            number_of_cell_cols = 8; %for rbe2, and rbe3 (maybe chexa aswell?
                        else
                            number_of_cell_cols = (full_line_text - cell_block_characters)/cell_block_characters;
                        end
                end
                %new_output_struct = new_output_lat
                %block = new_output_struct.(struct_names{i});
                [rows,cols] = size(block);

                %1 find number of columns to append if it is not a multiple of number_of_cell_cols
                
                if floor(cols/number_of_cell_cols)-cols/number_of_cell_cols ~=0
                    numcols_to_append = ceil(cols/number_of_cell_cols)*number_of_cell_cols - cols;
                    append_cols = nan(rows,numcols_to_append);
                    block = [block append_cols]; %#ok<AGROW>
                    [rows,cols] = size(block);
                end
                
                %2 organize rows into new matrix, cards are stacked one on
                %top of each other
                num_lines = cols/number_of_cell_cols; %number of rows per card
                col_indexes = [0 number_of_cell_cols:number_of_cell_cols:cols]; %index between columns of matrix
                new_matrix_block = zeros(numel(block)/number_of_cell_cols,number_of_cell_cols); %create new empty matrix
                num_new_rows = rows*num_lines;
                for w = 1:(length(col_indexes)-1)
                    row_select = w:num_lines:num_new_rows;
                    %grab columns
                    cols_ids = (col_indexes(w)+1):col_indexes(w+1);
                    new_matrix_block(row_select,:) = block(:,cols_ids);
                end
                
                %3 initilize empty cell structure (empty char array)
                tmp_cells = repmat({''},size(new_matrix_block,1),size(new_matrix_block,2));
                %4 find integer values and number lower than 10^cell_block_characters-1
                ints_bool = ((floor(new_matrix_block) - new_matrix_block) ==0) & (new_matrix_block < (10^cell_block_characters-1));
                nan_bool = isnan(new_matrix_block);
                %5 special case for BDF files (writting out the GRIDS)
                if contains(upper(file_type),'BDF') && contains(struct_names{i},'GRID')
                    %all the coordinates must be double
                    %first column is all integer values
                    %5 turn the integer places into character strings / cell_block_characters
                    tmp_cells(ints_bool(:,1)) = sprintfc('%8d',new_matrix_block(ints_bool(:,1)));
                    %the rest are doubles
                    ints_bool(:,2:end) = false;
                elseif contains(upper(file_type),'BDF') && contains(struct_names{i},'MAT1')
                    %col 2,3,4,5 are double
                    tmp_cells(ints_bool(:,1)) = sprintfc('%8d',new_matrix_block(ints_bool(:,1)));
                    ints_bool(:,2:5) = false;
                elseif contains(upper(file_type),'BDF') && contains(struct_names{i},'SPC')
                    %col 4 is double
                    tmp_cells(ints_bool(:,1:3)) = sprintfc('%8d',new_matrix_block(ints_bool(:,1:3)));
                    ints_bool(:,4) = false;
                elseif contains(upper(file_type),'BDF') && contains(struct_names{i},'FORCE')
                   %col 4 5 6 7 are double
                   %col 1 2 3 are integer
                   tmp_cells(ints_bool(:,1:3)) = sprintfc('%8d',new_matrix_block(ints_bool(:,1:3)));
                   ints_bool(:,[4 5 6 7]) = false;
                else    
                    %5 turn the integer places into character strings / cell_block_characters
                    tmp_cells(ints_bool) = sprintfc('%8d',new_matrix_block(ints_bool));
                end
                %6 find non-integer values and turn them into nastran short had strings
                tmp_cells(~ints_bool&~nan_bool) = num2cell(new_matrix_block(~ints_bool&~nan_bool));
                %6.5 create nastran short hand strings
                tmp_tmp = tmp_cells(~ints_bool&~nan_bool);
                num_tmp_cells = numel(tmp_tmp);
                parfor it = 1:num_tmp_cells
                    tmp_tmp{it} = num2nasSFFstr(tmp_tmp{it},cell_block_characters);
                end
                tmp_cells(~ints_bool&~nan_bool) = tmp_tmp;
                clear tmp_tmp
                %tmp_cells(~ints_bool&~nan_bool) = cellfun(@(v) num2nasSFFstr(v,cell_block_characters),tmp_cells(~ints_bool&~nan_bool),'UniformOutput',false); %expensive, bottleneck
                %7 append to new structure
                new_output_struct.(struct_names{i}) = mat2cell(tmp_cells,repmat(num_lines, 1,rows),number_of_cell_cols); %to reshape into final output

        otherwise 
                %nothing... 
        end


    end

end

end

%%%%%%%%%%%%%%%%%
%other functions%
%%%%%%%%%%%%%%%%%

function new_output_struct = read_general_chain(new_output_struct,struct_names,number_of_cell_cols,cell_block_characters,block,cols,i)
%for list, RB3's and e.t.c (with similar structure)    
    for d = 1:cols
        sub_block=block{d}; 
        %add required cells
        cell_row = mat2cell(sub_block,1,ones(numel(sub_block),1)); %#ok<MMTC>
        cells_num = numel(cell_row);
        num2add =number_of_cell_cols*ceil(cells_num/number_of_cell_cols) - cells_num;
        if num2add>0
            cell_add  = cell(1,num2add);
            cell_row = [cell_row cell_add] ;                                     %#ok<AGROW>
        end
        %reshape the cells
        cell_row=(reshape(cell_row,number_of_cell_cols,ceil(numel(cell_row)/number_of_cell_cols))');
        bool = cellfun(@isempty,cell_row);
        cell_row(~bool) = cellfun(@num2str, cell_row(~bool),'UniformOutput', false);
        cell_row(bool)={repmat(' ',1,cell_block_characters)}; %replace empty cells with whitespace
        new_output_struct.(struct_names{i}){d}=cell_row;
    end
end

%%%%%%%%%%%%%%%
%%%%OLD CODE%%%
%%%%%%%%%%%%%%%
%                 %fill in the blanks
%                 %general line by line in a matrix
%                 tic
%                 block = new_output_struct.(struct_names{i});
%                 [rows,cols] = size(block);
%                 new_output_struct.(struct_names{i}) = cell(rows,1);
%                 %new_output_struct.(struct_names{i}) = mat2cell(block,
%                 %ones(size(block,1),1), size(block,2) ); %cellfun is very slow sometimes, need to find a way to speed up this section using cellfun intelligently
%                 %emp_text = repmat(' ',1,cell_block_characters);
%                 for g = 1:rows
%                     %tic
%                     %cols needs to be the number of non nan types (trailing)
%                     %indexing to minimize looping will increase the speed dramatically for cellfun
%                     current_row = block(g,:);
%                     [sd,j] = ind2sub(size(current_row),find(~isnan(current_row)));
%                     l = min([sd j]);
%                     u = max([sd j]);
%                     current_row=current_row(l:u);
%                     cols = numel(current_row);
%                     cell_add = ceil(cols/number_of_cell_cols)*number_of_cell_cols -cols;
%                     %current_row = [current_row nan(1,cell_add)];
%                     matrix_row = vec2mat( [current_row nan(1,cell_add)],number_of_cell_cols);
%                     not_nums = isnan(matrix_row);
%                     ints = ((floor(matrix_row) - matrix_row) ==0) & (matrix_row < (10^cell_block_characters-1));
%                     %large_nums =  matrix_row > (10^cell_block_characters-1);
%                     cell_row=num2cell(matrix_row);
%                     cell_row(~(not_nums+ints)) = cellfun(@(v) num2nasSFFstr(v,cell_block_characters),cell_row(~(not_nums+ints)),'UniformOutput',false); %evaluate all numbers, integer can be larger than 8 spaces
%                     cell_row(not_nums) = {''};
%                     %convert integers into strings
%                     cell_row(ints) = cellfun(@num2str,(cell_row(ints)),'UniformOutput',false);
% 
%                     new_output_struct.(struct_names{i}){g}=cell_row;
%                 end     
%                 toc
